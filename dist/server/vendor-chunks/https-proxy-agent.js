"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/https-proxy-agent";
exports.ids = ["vendor-chunks/https-proxy-agent"];
exports.modules = {

/***/ "(ssr)/./node_modules/https-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(ssr)/./node_modules/agent-base/dist/src/index.js\");\nconst parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ \"(ssr)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\"));\nconst debug = debug_1.default(\"https-proxy-agent:agent\");\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */ class HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts){\n        let opts;\n        if (typeof _opts === \"string\") {\n            opts = url_1.default.parse(_opts);\n        } else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error(\"an HTTP(S) proxy server `host` and `port` must be specified!\");\n        }\n        debug(\"creating new HttpsProxyAgent instance: %o\", opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === \"string\") {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !(\"ALPNProtocols\" in proxy)) {\n            proxy.ALPNProtocols = [\n                \"http 1.1\"\n            ];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */ callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug(\"Creating `tls.Socket`: %o\", proxy);\n                socket = tls_1.default.connect(proxy);\n            } else {\n                debug(\"Creating `net.Socket`: %o\", proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers[\"Proxy-Authorization\"] = `Basic ${Buffer.from(proxy.auth).toString(\"base64\")}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = \"close\";\n            for (const name of Object.keys(headers)){\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once(\"socket\", resume);\n                if (opts.secureEndpoint) {\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug(\"Upgrading socket connection to TLS\");\n                    const servername = opts.servername || opts.host;\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, \"host\", \"hostname\", \"path\", \"port\")), {\n                        socket,\n                        servername\n                    }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket({\n                writable: false\n            });\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once(\"socket\", (s)=>{\n                debug(\"replaying proxy buffer for failed request\");\n                assert_1.default(s.listenerCount(\"data\") > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports[\"default\"] = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean(!secure && port === 80 || secure && port === 443);\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === \"string\" ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=agent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksSUFBSyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENB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SUFBS0EsT0FBT0YsSUFBSztRQUNiLElBQUksQ0FBQ3BCLEtBQUt1QixRQUFRLENBQUNELE1BQU07WUFDckJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHRixHQUFHLENBQUNFLElBQUk7UUFDdkI7SUFDSjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXJhbS1sbXMtZmUvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcz81NjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHRsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybFwiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgcGFyc2VfcHJveHlfcmVzcG9uc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS1wcm94eS1yZXNwb25zZVwiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnaHR0cHMtcHJveHktYWdlbnQ6YWdlbnQnKTtcbi8qKlxuICogVGhlIGBIdHRwc1Byb3h5QWdlbnRgIGltcGxlbWVudHMgYW4gSFRUUCBBZ2VudCBzdWJjbGFzcyB0aGF0IGNvbm5lY3RzIHRvXG4gKiB0aGUgc3BlY2lmaWVkIFwiSFRUUChzKSBwcm94eSBzZXJ2ZXJcIiBpbiBvcmRlciB0byBwcm94eSBIVFRQUyByZXF1ZXN0cy5cbiAqXG4gKiBPdXRnb2luZyBIVFRQIHJlcXVlc3RzIGFyZSBmaXJzdCB0dW5uZWxlZCB0aHJvdWdoIHRoZSBwcm94eSBzZXJ2ZXIgdXNpbmcgdGhlXG4gKiBgQ09OTkVDVGAgSFRUUCByZXF1ZXN0IG1ldGhvZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIsXG4gKiBhbmQgdGhlbiB0aGUgcHJveHkgc2VydmVyIGNvbm5lY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXQgYW5kIGlzc3VlcyB0aGVcbiAqIEhUVFAgcmVxdWVzdCBmcm9tIHRoZSBwcm94eSBzZXJ2ZXIuXG4gKlxuICogYGh0dHBzOmAgcmVxdWVzdHMgaGF2ZSB0aGVpciBzb2NrZXQgY29ubmVjdGlvbiB1cGdyYWRlZCB0byBUTFMgb25jZVxuICogdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBIdHRwc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRzKSB7XG4gICAgICAgIGxldCBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cyA9IHVybF8xLmRlZmF1bHQucGFyc2UoX29wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IF9vcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbiBIVFRQKFMpIHByb3h5IHNlcnZlciBgaG9zdGAgYW5kIGBwb3J0YCBtdXN0IGJlIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnY3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCBvcHRzKTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gICAgICAgIC8vIElmIGB0cnVlYCwgdGhlbiBjb25uZWN0IHRvIHRoZSBwcm94eSBzZXJ2ZXIgb3ZlciBUTFMuXG4gICAgICAgIC8vIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgIHRoaXMuc2VjdXJlUHJveHkgPSBvcHRzLnNlY3VyZVByb3h5IHx8IGlzSFRUUFMocHJveHkucHJvdG9jb2wpO1xuICAgICAgICAvLyBQcmVmZXIgYGhvc3RuYW1lYCBvdmVyIGBob3N0YCwgYW5kIHNldCB0aGUgYHBvcnRgIGlmIG5lZWRlZC5cbiAgICAgICAgcHJveHkuaG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcHJveHkucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSBwYXJzZUludChwcm94eS5wb3J0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm94eS5wb3J0ICYmIHByb3h5Lmhvc3QpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSB0aGlzLnNlY3VyZVByb3h5ID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQUxQTiBpcyBzdXBwb3J0ZWQgYnkgTm9kZS5qcyA+PSB2NS5cbiAgICAgICAgLy8gYXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMlxuICAgICAgICBpZiAodGhpcy5zZWN1cmVQcm94eSAmJiAhKCdBTFBOUHJvdG9jb2xzJyBpbiBwcm94eSkpIHtcbiAgICAgICAgICAgIHByb3h5LkFMUE5Qcm90b2NvbHMgPSBbJ2h0dHAgMS4xJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3h5Lmhvc3QgJiYgcHJveHkucGF0aCkge1xuICAgICAgICAgICAgLy8gSWYgYm90aCBhIGBob3N0YCBhbmQgYHBhdGhgIGFyZSBzcGVjaWZpZWQgdGhlbiBpdCdzIG1vc3QgbGlrZWx5XG4gICAgICAgICAgICAvLyB0aGUgcmVzdWx0IG9mIGEgYHVybC5wYXJzZSgpYCBjYWxsLi4uIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gYHBhdGhgIHBvcnRpb24gc28gdGhhdCBgbmV0LmNvbm5lY3QoKWAgZG9lc24ndCBhdHRlbXB0IHRvIG9wZW5cbiAgICAgICAgICAgIC8vIHRoYXQgYXMgYSBVbml4IHNvY2tldCBmaWxlLlxuICAgICAgICAgICAgZGVsZXRlIHByb3h5LnBhdGg7XG4gICAgICAgICAgICBkZWxldGUgcHJveHkucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZS1jb3JlIEhUVFAgY2xpZW50IGxpYnJhcnkgaXMgY3JlYXRpbmcgYVxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm94eSwgc2VjdXJlUHJveHkgfSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLlxuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIGlmIChzZWN1cmVQcm94eSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgdGxzLlNvY2tldGA6ICVvJywgcHJveHkpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IHRsc18xLmRlZmF1bHQuY29ubmVjdChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYG5ldC5Tb2NrZXRgOiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXRfMS5kZWZhdWx0LmNvbm5lY3QocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3h5LmhlYWRlcnMpO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBgJHtvcHRzLmhvc3R9OiR7b3B0cy5wb3J0fWA7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IGBDT05ORUNUICR7aG9zdG5hbWV9IEhUVFAvMS4xXFxyXFxuYDtcbiAgICAgICAgICAgIC8vIEluamVjdCB0aGUgYFByb3h5LUF1dGhvcml6YXRpb25gIGhlYWRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAocHJveHkuYXV0aCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKHByb3h5LmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGBIb3N0YCBoZWFkZXIgc2hvdWxkIG9ubHkgaW5jbHVkZSB0aGUgcG9ydFxuICAgICAgICAgICAgLy8gbnVtYmVyIHdoZW4gaXQgaXMgbm90IHRoZSBkZWZhdWx0IHBvcnQuXG4gICAgICAgICAgICBsZXQgeyBob3N0LCBwb3J0LCBzZWN1cmVFbmRwb2ludCB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0UG9ydChwb3J0LCBzZWN1cmVFbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICBob3N0ICs9IGA6JHtwb3J0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLkhvc3QgPSBob3N0O1xuICAgICAgICAgICAgaGVhZGVycy5Db25uZWN0aW9uID0gJ2Nsb3NlJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgKz0gYCR7bmFtZX06ICR7aGVhZGVyc1tuYW1lXX1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJveHlSZXNwb25zZVByb21pc2UgPSBwYXJzZV9wcm94eV9yZXNwb25zZV8xLmRlZmF1bHQoc29ja2V0KTtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtwYXlsb2FkfVxcclxcbmApO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlLCBidWZmZXJlZCB9ID0geWllbGQgcHJveHlSZXNwb25zZVByb21pc2U7XG4gICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIHJlc3VtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZSB8fCBvcHRzLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bHNfMS5kZWZhdWx0LmNvbm5lY3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbWl0KG9wdHMsICdob3N0JywgJ2hvc3RuYW1lJywgJ3BhdGgnLCAncG9ydCcpKSwgeyBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgc3RhdHVzIGNvZGUgdGhhdCdzIG5vdCAyMDAuLi4gbmVlZCB0byByZS1wbGF5IHRoZSBIVFRQXG4gICAgICAgICAgICAvLyBoZWFkZXIgXCJkYXRhXCIgZXZlbnRzIG9udG8gdGhlIHNvY2tldCBvbmNlIHRoZSBIVFRQIG1hY2hpbmVyeSBpc1xuICAgICAgICAgICAgLy8gYXR0YWNoZWQgc28gdGhhdCB0aGUgbm9kZSBjb3JlIGBodHRwYCBjYW4gcGFyc2UgYW5kIGhhbmRsZSB0aGVcbiAgICAgICAgICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlLlxuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIG9yaWdpbmFsIHNvY2tldCwgYW5kIGEgbmV3IFwiZmFrZVwiIHNvY2tldCBpcyByZXR1cm5lZFxuICAgICAgICAgICAgLy8gaW5zdGVhZCwgc28gdGhhdCB0aGUgcHJveHkgZG9lc24ndCBnZXQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAgICAgLy8gd3JpdHRlbiB0byBpdCAod2hpY2ggbWF5IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gIGhlYWRlcnMgb3Igb3RoZXJcbiAgICAgICAgICAgIC8vIHNlbnNpdGl2ZSBkYXRhKS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vaGFja2Vyb25lLmNvbS9yZXBvcnRzLzU0MTUwMlxuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNvbnN0IGZha2VTb2NrZXQgPSBuZXcgbmV0XzEuZGVmYXVsdC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBmYWtlU29ja2V0LnJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdGhlIFwic29ja2V0XCIgZXZlbnQgdG8gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzLlxuICAgICAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIChzKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3JlcGxheWluZyBwcm94eSBidWZmZXIgZm9yIGZhaWxlZCByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgXCJidWZmZXJlZFwiIEJ1ZmZlciBvbnRvIHRoZSBmYWtlIGBzb2NrZXRgLCBzaW5jZSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgdGhlIEhUVFAgbW9kdWxlIG1hY2hpbmVyeSBoYXMgYmVlbiBob29rZWQgdXAgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgcy5wdXNoKGJ1ZmZlcmVkKTtcbiAgICAgICAgICAgICAgICBzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWtlU29ja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwc1Byb3h5QWdlbnQ7XG5mdW5jdGlvbiByZXN1bWUoc29ja2V0KSB7XG4gICAgc29ja2V0LnJlc3VtZSgpO1xufVxuZnVuY3Rpb24gaXNEZWZhdWx0UG9ydChwb3J0LCBzZWN1cmUpIHtcbiAgICByZXR1cm4gQm9vbGVhbigoIXNlY3VyZSAmJiBwb3J0ID09PSA4MCkgfHwgKHNlY3VyZSAmJiBwb3J0ID09PSA0NDMpKTtcbn1cbmZ1bmN0aW9uIGlzSFRUUFMocHJvdG9jb2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3RvY29sID09PSAnc3RyaW5nJyA/IC9eaHR0cHM6PyQvaS50ZXN0KHByb3RvY29sKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdlbnQuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJuZXRfMSIsInJlcXVpcmUiLCJ0bHNfMSIsInVybF8xIiwiYXNzZXJ0XzEiLCJkZWJ1Z18xIiwiYWdlbnRfYmFzZV8xIiwicGFyc2VfcHJveHlfcmVzcG9uc2VfMSIsImRlYnVnIiwiZGVmYXVsdCIsIkh0dHBzUHJveHlBZ2VudCIsIkFnZW50IiwiY29uc3RydWN0b3IiLCJfb3B0cyIsIm9wdHMiLCJwYXJzZSIsIkVycm9yIiwicHJveHkiLCJhc3NpZ24iLCJzZWN1cmVQcm94eSIsImlzSFRUUFMiLCJwcm90b2NvbCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJwYXJzZUludCIsIkFMUE5Qcm90b2NvbHMiLCJwYXRoIiwicGF0aG5hbWUiLCJjYWxsYmFjayIsInJlcSIsInNvY2tldCIsImNvbm5lY3QiLCJoZWFkZXJzIiwicGF5bG9hZCIsImF1dGgiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJzZWN1cmVFbmRwb2ludCIsImlzRGVmYXVsdFBvcnQiLCJIb3N0IiwiQ29ubmVjdGlvbiIsIm5hbWUiLCJrZXlzIiwicHJveHlSZXNwb25zZVByb21pc2UiLCJ3cml0ZSIsInN0YXR1c0NvZGUiLCJidWZmZXJlZCIsIm9uY2UiLCJyZXN1bWUiLCJzZXJ2ZXJuYW1lIiwib21pdCIsImRlc3Ryb3kiLCJmYWtlU29ja2V0IiwiU29ja2V0Iiwid3JpdGFibGUiLCJyZWFkYWJsZSIsInMiLCJsaXN0ZW5lckNvdW50IiwicHVzaCIsInNlY3VyZSIsIkJvb2xlYW4iLCJ0ZXN0Iiwib2JqIiwicmV0Iiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/https-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/https-proxy-agent/dist/agent.js\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function(createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQSxNQUFNRSxVQUFVSCxnQkFBZ0JJLG1CQUFPQSxDQUFDLHFFQUFTO0FBQ2pELFNBQVNDLHNCQUFzQkMsSUFBSTtJQUMvQixPQUFPLElBQUlILFFBQVFJLE9BQU8sQ0FBQ0Q7QUFDL0I7QUFDQyxVQUFVRCxxQkFBcUI7SUFDNUJBLHNCQUFzQkcsZUFBZSxHQUFHTCxRQUFRSSxPQUFPO0lBQ3ZERixzQkFBc0JJLFNBQVMsR0FBR04sUUFBUUksT0FBTyxDQUFDRSxTQUFTO0FBQy9ELEdBQUdKLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDdERLLE9BQU9DLE9BQU8sR0FBR04sdUJBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BhcmFtLWxtcy1mZS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzP2YyZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBhZ2VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FnZW50XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBzUHJveHlBZ2VudChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBhZ2VudF8xLmRlZmF1bHQob3B0cyk7XG59XG4oZnVuY3Rpb24gKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCkge1xuICAgIGNyZWF0ZUh0dHBzUHJveHlBZ2VudC5IdHRwc1Byb3h5QWdlbnQgPSBhZ2VudF8xLmRlZmF1bHQ7XG4gICAgY3JlYXRlSHR0cHNQcm94eUFnZW50LnByb3RvdHlwZSA9IGFnZW50XzEuZGVmYXVsdC5wcm90b3R5cGU7XG59KShjcmVhdGVIdHRwc1Byb3h5QWdlbnQgfHwgKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCA9IHt9KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUh0dHBzUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiYWdlbnRfMSIsInJlcXVpcmUiLCJjcmVhdGVIdHRwc1Byb3h5QWdlbnQiLCJvcHRzIiwiZGVmYXVsdCIsIkh0dHBzUHJveHlBZ2VudCIsInByb3RvdHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst debug = debug_1.default(\"https-proxy-agent:parse-proxy-response\");\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject)=>{\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b) ondata(b);\n            else socket.once(\"readable\", read);\n        }\n        function cleanup() {\n            socket.removeListener(\"end\", onend);\n            socket.removeListener(\"error\", onerror);\n            socket.removeListener(\"close\", onclose);\n            socket.removeListener(\"readable\", read);\n        }\n        function onclose(err) {\n            debug(\"onclose had error %o\", err);\n        }\n        function onend() {\n            debug(\"onend\");\n        }\n        function onerror(err) {\n            cleanup();\n            debug(\"onerror %o\", err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf(\"\\r\\n\\r\\n\");\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug(\"have not received end of HTTP headers yet...\");\n                read();\n                return;\n            }\n            const firstLine = buffered.toString(\"ascii\", 0, buffered.indexOf(\"\\r\\n\"));\n            const statusCode = +firstLine.split(\" \")[1];\n            debug(\"got proxy server response: %o\", firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on(\"error\", onerror);\n        socket.on(\"close\", onclose);\n        socket.on(\"end\", onend);\n        read();\n    });\n}\nexports[\"default\"] = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVVAsZ0JBQWdCUSxtQkFBT0EsQ0FBQyxzREFBTztBQUMvQyxNQUFNQyxRQUFRRixRQUFRRyxPQUFPLENBQUM7QUFDOUIsU0FBU0MsbUJBQW1CQyxNQUFNO0lBQzlCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUN6QiwrRUFBK0U7UUFDL0UsZ0ZBQWdGO1FBQ2hGLDhFQUE4RTtRQUM5RSw4QkFBOEI7UUFDOUIsSUFBSUMsZ0JBQWdCO1FBQ3BCLE1BQU1DLFVBQVUsRUFBRTtRQUNsQixTQUFTQztZQUNMLE1BQU1DLElBQUlQLE9BQU9NLElBQUk7WUFDckIsSUFBSUMsR0FDQUMsT0FBT0Q7aUJBRVBQLE9BQU9TLElBQUksQ0FBQyxZQUFZSDtRQUNoQztRQUNBLFNBQVNJO1lBQ0xWLE9BQU9XLGNBQWMsQ0FBQyxPQUFPQztZQUM3QlosT0FBT1csY0FBYyxDQUFDLFNBQVNFO1lBQy9CYixPQUFPVyxjQUFjLENBQUMsU0FBU0c7WUFDL0JkLE9BQU9XLGNBQWMsQ0FBQyxZQUFZTDtRQUN0QztRQUNBLFNBQVNRLFFBQVFDLEdBQUc7WUFDaEJsQixNQUFNLHdCQUF3QmtCO1FBQ2xDO1FBQ0EsU0FBU0g7WUFDTGYsTUFBTTtRQUNWO1FBQ0EsU0FBU2dCLFFBQVFFLEdBQUc7WUFDaEJMO1lBQ0FiLE1BQU0sY0FBY2tCO1lBQ3BCWixPQUFPWTtRQUNYO1FBQ0EsU0FBU1AsT0FBT0QsQ0FBQztZQUNiRixRQUFRVyxJQUFJLENBQUNUO1lBQ2JILGlCQUFpQkcsRUFBRVUsTUFBTTtZQUN6QixNQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUNmLFNBQVNEO1lBQ3hDLE1BQU1pQixlQUFlSCxTQUFTSSxPQUFPLENBQUM7WUFDdEMsSUFBSUQsaUJBQWlCLENBQUMsR0FBRztnQkFDckIsaUJBQWlCO2dCQUNqQnhCLE1BQU07Z0JBQ05TO2dCQUNBO1lBQ0o7WUFDQSxNQUFNaUIsWUFBWUwsU0FBU00sUUFBUSxDQUFDLFNBQVMsR0FBR04sU0FBU0ksT0FBTyxDQUFDO1lBQ2pFLE1BQU1HLGFBQWEsQ0FBQ0YsVUFBVUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNDN0IsTUFBTSxpQ0FBaUMwQjtZQUN2Q3JCLFFBQVE7Z0JBQ0p1QjtnQkFDQVA7WUFDSjtRQUNKO1FBQ0FsQixPQUFPMkIsRUFBRSxDQUFDLFNBQVNkO1FBQ25CYixPQUFPMkIsRUFBRSxDQUFDLFNBQVNiO1FBQ25CZCxPQUFPMkIsRUFBRSxDQUFDLE9BQU9mO1FBQ2pCTjtJQUNKO0FBQ0o7QUFDQWIsa0JBQWUsR0FBR00sb0JBQ2xCLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BhcmFtLWxtcy1mZS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzP2NkMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcbmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gICAgICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgICAgICAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gICAgICAgIGxldCBidWZmZXJzTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb25jbG9zZSBoYWQgZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgZGVidWcoJ29uZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGRlYnVnKCdvbmVycm9yICVvJywgZXJyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZGF0YShiKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goYik7XG4gICAgICAgICAgICBidWZmZXJzTGVuZ3RoICs9IGIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIGJ1ZmZlcnNMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAoZW5kT2ZIZWFkZXJzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgYnVmZmVyaW5nXG4gICAgICAgICAgICAgICAgZGVidWcoJ2hhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uJyk7XG4gICAgICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGJ1ZmZlcmVkLnRvU3RyaW5nKCdhc2NpaScsIDAsIGJ1ZmZlcmVkLmluZGV4T2YoJ1xcclxcbicpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSArZmlyc3RMaW5lLnNwbGl0KCcgJylbMV07XG4gICAgICAgICAgICBkZWJ1ZygnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8nLCBmaXJzdExpbmUpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICBidWZmZXJlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpO1xuICAgICAgICByZWFkKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVByb3h5UmVzcG9uc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1wcm94eS1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVidWdfMSIsInJlcXVpcmUiLCJkZWJ1ZyIsImRlZmF1bHQiLCJwYXJzZVByb3h5UmVzcG9uc2UiLCJzb2NrZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImJ1ZmZlcnNMZW5ndGgiLCJidWZmZXJzIiwicmVhZCIsImIiLCJvbmRhdGEiLCJvbmNlIiwiY2xlYW51cCIsInJlbW92ZUxpc3RlbmVyIiwib25lbmQiLCJvbmVycm9yIiwib25jbG9zZSIsImVyciIsInB1c2giLCJsZW5ndGgiLCJidWZmZXJlZCIsIkJ1ZmZlciIsImNvbmNhdCIsImVuZE9mSGVhZGVycyIsImluZGV4T2YiLCJmaXJzdExpbmUiLCJ0b1N0cmluZyIsInN0YXR1c0NvZGUiLCJzcGxpdCIsIm9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ })

};
;